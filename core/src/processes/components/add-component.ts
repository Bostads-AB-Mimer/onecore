import { ProcessResult, ProcessStatus } from '../../common/types'
import { logger } from '@onecore/utilities'
import { AddComponentErrorCodes } from '@onecore/types'
import * as propertyBaseAdapter from '../../adapters/property-base-adapter'
import { components } from '../../adapters/property-base-adapter/generated/api-types'

// Type aliases for autogenerated types
type CreateModelRequest = components['schemas']['CreateComponentModelRequest']
type CreateComponentRequestType =
  components['schemas']['CreateComponentRequest']
type CreateInstallationRequest =
  components['schemas']['CreateComponentInstallationRequest']

//
// PROCESS (Add Component)
//
// Description: Unified process to add a component with all required dependencies.
// This process handles the creation of a component instance and its installation,
// optionally creating the component model if it doesn't exist.
//
// Steps:
// 1. Validate that the component subtype exists
// 2. Find existing model by exact modelName match
//    - If not found, validate model fields and create new model
// 3. Create component instance
// 4. Create component installation
//
// Error Recovery:
// - If installation creation fails, delete the component (cleanup orphan)
// - Leave newly created models on failure (they're reusable)
//
// Future enhancements (TODO):
// - Upload component images via document microservice
// - Upload component files/documents via document microservice
//

export interface AddComponentRequest {
  // Model lookup/creation
  modelName: CreateModelRequest['modelName']
  componentSubtypeId: CreateModelRequest['componentSubtypeId']

  // Model fields - REQUIRED if model doesn't exist, ignored if model exists
  manufacturer?: CreateModelRequest['manufacturer']
  currentPrice?: CreateModelRequest['currentPrice']
  currentInstallPrice?: CreateModelRequest['currentInstallPrice']
  modelWarrantyMonths?: CreateModelRequest['warrantyMonths']
  technicalSpecification?: CreateModelRequest['technicalSpecification']
  dimensions?: CreateModelRequest['dimensions']
  coclassCode?: CreateModelRequest['coclassCode']

  // Component instance info
  serialNumber: NonNullable<CreateComponentRequestType['serialNumber']>
  specifications?: CreateComponentRequestType['specifications']
  additionalInformation?: CreateComponentRequestType['additionalInformation']
  warrantyStartDate?: CreateComponentRequestType['warrantyStartDate']
  componentWarrantyMonths: CreateComponentRequestType['warrantyMonths']
  priceAtPurchase: CreateComponentRequestType['priceAtPurchase']
  depreciationPriceAtPurchase: CreateComponentRequestType['depreciationPriceAtPurchase']
  economicLifespan: CreateComponentRequestType['economicLifespan']
  quantity?: CreateComponentRequestType['quantity']
  ncsCode?: CreateComponentRequestType['ncsCode']
  status?: CreateComponentRequestType['status']
  condition?: CreateComponentRequestType['condition']

  // Installation info
  spaceId: NonNullable<CreateInstallationRequest['spaceId']>
  spaceType: CreateInstallationRequest['spaceType']
  installationDate: CreateInstallationRequest['installationDate']
  orderNumber?: CreateInstallationRequest['orderNumber']
  installationCost: CreateInstallationRequest['cost']
}

export interface AddComponentResponse {
  modelCreated: boolean
  model: {
    id: string
    modelName: string
    manufacturer: string
  }
  component: {
    id: string
    serialNumber: string
    status: string
  }
  installation: {
    id: string
    spaceId: string
    installationDate: string
  }
}

export const addComponent = async (
  request: AddComponentRequest
): Promise<ProcessResult<AddComponentResponse, AddComponentErrorCodes>> => {
  try {
    // Step 1: Validate subtype exists
    const subtypeResult = await propertyBaseAdapter.getComponentSubtypeById(
      request.componentSubtypeId
    )

    if (!subtypeResult.ok) {
      return {
        processStatus: ProcessStatus.failed,
        error: AddComponentErrorCodes.SubtypeNotFound,
        httpStatus: 400,
        response: {
          message: `Component subtype ${request.componentSubtypeId} not found. Categories, types, and subtypes must be created manually.`,
        },
      }
    }

    // Step 2: Find existing model by exact name match
    let modelId: string
    let modelCreated = false
    let modelData: { id: string; modelName: string; manufacturer: string }

    const existingModelResult = await propertyBaseAdapter.findModelByExactName(
      request.modelName
    )

    if (existingModelResult.ok) {
      // Model exists, use it
      modelId = existingModelResult.data.id
      modelData = {
        id: existingModelResult.data.id,
        modelName: existingModelResult.data.modelName,
        manufacturer: existingModelResult.data.manufacturer,
      }
      logger.info(
        { modelId, modelName: request.modelName },
        'Found existing model by name'
      )
    } else if (existingModelResult.err === 'not_found') {
      // Model doesn't exist, validate required fields and create it
      const missingFields: string[] = []
      if (!request.manufacturer) missingFields.push('manufacturer')
      if (request.currentPrice === undefined) missingFields.push('currentPrice')
      if (request.currentInstallPrice === undefined)
        missingFields.push('currentInstallPrice')
      if (request.modelWarrantyMonths === undefined)
        missingFields.push('modelWarrantyMonths')

      if (missingFields.length > 0) {
        return {
          processStatus: ProcessStatus.failed,
          error: AddComponentErrorCodes.MissingModelFields,
          httpStatus: 400,
          response: {
            message: `Model "${request.modelName}" does not exist. The following fields are required to create it: ${missingFields.join(', ')}`,
            missingFields,
          },
        }
      }

      // Create the model
      const createModelResult = await propertyBaseAdapter.createComponentModel({
        modelName: request.modelName,
        componentSubtypeId: request.componentSubtypeId,
        manufacturer: request.manufacturer!,
        currentPrice: request.currentPrice!,
        currentInstallPrice: request.currentInstallPrice!,
        warrantyMonths: request.modelWarrantyMonths!,
        technicalSpecification: request.technicalSpecification,
        dimensions: request.dimensions,
        coclassCode: request.coclassCode,
      })

      if (!createModelResult.ok) {
        logger.error(
          { modelName: request.modelName, err: createModelResult.err },
          'Failed to create component model'
        )
        return {
          processStatus: ProcessStatus.failed,
          error: AddComponentErrorCodes.ModelCreationFailed,
          httpStatus: 500,
          response: {
            message: `Failed to create component model "${request.modelName}".`,
          },
        }
      }

      modelId = createModelResult.data.id
      modelCreated = true
      modelData = {
        id: createModelResult.data.id,
        modelName: createModelResult.data.modelName,
        manufacturer: createModelResult.data.manufacturer,
      }
      logger.info(
        { modelId, modelName: request.modelName },
        'Created new component model'
      )
    } else {
      // Unexpected error finding model
      logger.error(
        { modelName: request.modelName, err: existingModelResult.err },
        'Error finding component model'
      )
      return {
        processStatus: ProcessStatus.failed,
        error: AddComponentErrorCodes.InternalError,
        httpStatus: 500,
        response: {
          message: `Error looking up component model "${request.modelName}".`,
        },
      }
    }

    // Step 3: Create component instance
    // Convert warrantyStartDate to full ISO-8601 DateTime format
    // Prisma expects full DateTime format (e.g., "2026-01-01T00:00:00.000Z")
    const warrantyStartDateISO = request.warrantyStartDate
      ? new Date(request.warrantyStartDate).toISOString()
      : undefined

    const createComponentResult = await propertyBaseAdapter.createComponent({
      modelId,
      serialNumber: request.serialNumber,
      specifications: request.specifications,
      additionalInformation: request.additionalInformation,
      warrantyStartDate: warrantyStartDateISO,
      warrantyMonths: request.componentWarrantyMonths,
      priceAtPurchase: request.priceAtPurchase,
      depreciationPriceAtPurchase: request.depreciationPriceAtPurchase,
      economicLifespan: request.economicLifespan,
      quantity: request.quantity ?? 1,
      ncsCode: request.ncsCode,
      status: request.status ?? 'ACTIVE',
      condition: request.condition,
    })

    if (!createComponentResult.ok) {
      logger.error(
        { modelId, serialNumber: request.serialNumber },
        'Failed to create component instance'
      )
      // Note: We don't delete the model here - it's reusable
      return {
        processStatus: ProcessStatus.failed,
        error: AddComponentErrorCodes.ComponentCreationFailed,
        httpStatus: 500,
        response: {
          message: `Failed to create component instance with serial number "${request.serialNumber}".`,
          modelCreated,
          modelId,
        },
      }
    }

    const componentId = createComponentResult.data.id
    logger.info(
      { componentId, serialNumber: request.serialNumber },
      'Created component instance'
    )

    // Step 4: Create component installation
    const createInstallationResult =
      await propertyBaseAdapter.createComponentInstallation({
        componentId,
        spaceId: request.spaceId,
        spaceType: request.spaceType,
        installationDate: request.installationDate,
        orderNumber: request.orderNumber,
        cost: request.installationCost,
      })

    if (!createInstallationResult.ok) {
      logger.error(
        { componentId, spaceId: request.spaceId },
        'Failed to create installation - cleaning up component'
      )

      // Cleanup: Delete the orphan component
      await propertyBaseAdapter.deleteComponent(componentId)

      return {
        processStatus: ProcessStatus.failed,
        error: AddComponentErrorCodes.InstallationCreationFailed,
        httpStatus: 500,
        response: {
          message: `Failed to create installation for component in space "${request.spaceId}". Component has been cleaned up.`,
          modelCreated,
          modelId,
        },
      }
    }

    logger.info(
      {
        componentId,
        installationId: createInstallationResult.data.id,
        spaceId: request.spaceId,
      },
      'Created component installation'
    )

    // TODO: Future enhancement - Upload component images via document microservice
    // TODO: Future enhancement - Upload component files/documents via document microservice

    return {
      processStatus: ProcessStatus.successful,
      httpStatus: 201,
      data: {
        modelCreated,
        model: modelData,
        component: {
          id: componentId,
          serialNumber: createComponentResult.data.serialNumber ?? '',
          status: createComponentResult.data.status,
        },
        installation: {
          id: createInstallationResult.data.id,
          spaceId: createInstallationResult.data.spaceId ?? '',
          installationDate: createInstallationResult.data.installationDate,
        },
      },
      response: {
        message: modelCreated
          ? 'Component added successfully with new model.'
          : 'Component added successfully using existing model.',
      },
    }
  } catch (error: any) {
    logger.error(error, 'Add component process uncaught error')
    return {
      processStatus: ProcessStatus.failed,
      error: AddComponentErrorCodes.InternalError,
      httpStatus: 500,
      response: {
        message: error.message,
      },
    }
  }
}
